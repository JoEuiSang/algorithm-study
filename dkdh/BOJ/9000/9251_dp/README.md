# 9251번 LCS
[문제 보러가기](https://www.acmicpc.net/problem/9251)

## 🅰 설계

Longest Common Subsequence   
이 문제는 두 문자열을 입력으로 받아 가장 긴 공통 부분 Subsequence의 길이를 찾는 문제이다.   
Substring은 연속적인 문자열이고, Subsequence는 연속적이지 않고 순서만 맞으면 되는 것.

이 문제는 다시 작은 부분 문제로 나눌 수 있는데,   
예시 문자열 ACAYKP와 CAPCAK로 살펴보자면   
우리가 찾고자 하는 LCS가
1. A로 시작하는 경우
2. C로 시작하는 경우
3. A나 C로 시작하지 않는 경우
로 나뉠 수 있다.

1번 A로 시작하는 경우, 두번째 문자열의 C는 배제하고 ACAYKP와 APCAK의 문제로 볼 수 있다.   
2번 C로 시작하는 경우, 첫번째 문자열의 A는 배제하고 CAYKP와 CAPCAK의 문제로 볼 수 있다.   
3번 둘 다 아닌 경우, 두 문자 모두 제외하고 CAYKP와 APCAK의 문제로 볼 수 있다.   
또한 두 문자열이 같은 문자로 시작한다면 해당 문자를 LCS에 포함시키고 두 문자열에서 배제할 수 있다.   

즉 이 문제는 같지만 사이즈가 더 작은 부분 문제들을 통해 해결할 수 있으며,   
이 때 앞선 결과를 저장해 활용할 수 있다.

정리하자면 두 문자열을 한 문자씩 살펴보면서,   
만약 두 문자가 같지 않다면 둘 중 한 문자를 배제시키고(더 작은 부분 문제가 된다),   
두 문자가 같다면 LCS의 길이를 갱신하는 방식으로 문제를 해결할 수 있다.

```
  A C A Y K P
C 0 1 1 1 1 1
A 1 1 2 2 2 2
P 1 1 2 2 2 3
C 1 2 2 2 2 3
A 1 2 3 3 3 3
K 1 2 3 3 4 4
```
위 표를 채우는 것이 작은 부분 문제들을 해결하는 방법이라고 할 수 있다.

이 표는, 예를 들어 (2, 2)를 본다면 문자열 "AC"와 문자열 "CA" 간의 LCS의 길이를 구한 것이라고 할 수 있다.   
각 칸을 채울 때, 해당 칸의 행과 열의 문자가 그 시점에 살펴보는 각 부분 문자열의 마지막 문자라고 생각하면 된다.

칸을 채우는 방법은   
행과 열의 문자가 같지 않을 때: 왼쪽 칸과 윗 칸 중 큰 수를 선택해 채워 넣고,   
행과 열의 문자가 같을 때: 왼쪽 위 대각선 칸의 수 + 1 로 채우면 된다.

문자가 같지 않을 때 왼쪽 칸과 윗 칸 중 큰 수를 선택하는 것은 이전까지 구한 Subsequence 길이 중 가장 큰 값을 가지고 오는 것이다.   
문자가 같을 때 해당 행과 열의 문자는 Subsequence의 마지막 문자로 포함되기 때문에 같은 행이나 열의 수가 아닌, 왼쪽 위 대각선의 값에 +1을 해 최대 LCS의 값을 정한다.

정리
2차원 배열을 만들어서 문자열의 문자를 차례대로 비교해 배열을 채운다.   
답은 문자열 전체에 대한 LCS 값이 저장될 오른쪽 맨 아래 값!

이때 2차원 배열은 실제 문자열의 길이보다 +1씩 해서 만들어주는데,   
이를 0으로 채워줌으로써 각 문자열의 첫 문자에 대해서도(즉 표의 행과 열 첫 줄) 왼쪽 칸과 윗 칸 중 max 값을 가져오는 일관성을 지킬 수 있기 때문이다.

```
Scanner sc = new Scanner(System.in);
		
		//문자열 두 개 입력받기
		String str1 = sc.nextLine();
		String str2 = sc.nextLine();
		
		int size1 = str1.length();
		int size2 = str2.length();
		
		//각 부분 문자열에 대한 LCS를 기억할 배열 생성
		int lcs[][] = new int[size1+1][size2+1];
		
		//표 채워넣기
		for (int i = 0; i < size1; i++) {
			for (int j = 0; j < size2; j++) {
				if(str1.charAt(i)==str2.charAt(j))
					lcs[i+1][j+1] = lcs[i][j] + 1;
				else
					lcs[i+1][j+1] = Math.max(lcs[i][j+1], lcs[i+1][j]);
			}
		}
		
		//결과 출력
		System.out.print(lcs[size1][size2]);
		
		sc.close();
```

## ✅ 후기
새롭게 알게되거나 공유해서 알게된 점   

고생한 점   
은근 말로 깔끔하게 정리하려니 힘드네요 + 마크다운 많이 안 써봐서ㅋ큐ㅠ
